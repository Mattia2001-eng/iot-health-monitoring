# requirements.txt
Flask==2.3.2
Flask-SQLAlchemy==3.0.5
Flask-Login==0.6.2
pandas==2.0.3
numpy==1.24.3
requests==2.31.0
python-dotenv==1.0.0
Werkzeug==2.3.6

# Per produzione
gunicorn==21.2.0
psycopg2-binary==2.9.6

# docker-compose.yml
version: '3.8'

services:
  # Database PostgreSQL
  postgres:
    image: postgres:15-alpine
    container_name: health_monitor_db
    environment:
      POSTGRES_DB: health_monitoring
      POSTGRES_USER: health_user
      POSTGRES_PASSWORD: ${DB_PASSWORD:-secure_password_here}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    networks:
      - health_network
    restart: unless-stopped

  # Server Flask
  web:
    build: .
    container_name: health_monitor_server
    environment:
      DATABASE_URL: postgresql://health_user:${DB_PASSWORD:-secure_password_here}@postgres:5432/health_monitoring
      SECRET_KEY: ${SECRET_KEY:-your-secret-key-here}
      EMAIL_SENDER: ${EMAIL_SENDER}
      EMAIL_PASSWORD: ${EMAIL_PASSWORD}
      FLASK_ENV: production
    ports:
      - "5000:5000"
    depends_on:
      - postgres
    volumes:
      - ./server:/app
      - ./data:/data
    networks:
      - health_network
    restart: unless-stopped
    command: gunicorn -w 4 -b 0.0.0.0:5000 app:app

  # Client sensori (esempio per un client)
  sensor_client_1:
    build: 
      context: .
      dockerfile: Dockerfile.client
    container_name: sensor_client_1
    environment:
      SERVER_URL: http://web:5000
      CLIENT_ID: user1_device1
      DATA_FOLDER: /data/fatigueset
      SPEED_MULTIPLIER: 10
    volumes:
      - ./data:/data
    depends_on:
      - web
    networks:
      - health_network
    restart: unless-stopped

volumes:
  postgres_data:

networks:
  health_network:
    driver: bridge

# Dockerfile (per il server)
FROM python:3.10-slim

WORKDIR /app

# Installa dipendenze di sistema
RUN apt-get update && apt-get install -y \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# Copia requirements e installa dipendenze Python
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copia il codice dell'applicazione
COPY server/ .

# Esponi la porta
EXPOSE 5000

# Comando di default
CMD ["gunicorn", "-w", "4", "-b", "0.0.0.0:5000", "app:app"]

# Dockerfile.client (per i client)
FROM python:3.10-slim

WORKDIR /app

# Installa dipendenze
COPY requirements.txt .
RUN pip install --no-cache-dir pandas requests numpy

# Copia il client
COPY client/sensor_client.py .

# Comando di default
CMD ["python", "sensor_client.py", \
     "--server", "${SERVER_URL}", \
     "--client-id", "${CLIENT_ID}", \
     "--data-folder", "${DATA_FOLDER}", \
     "--speed", "${SPEED_MULTIPLIER:-1}"]

# .env (file di configurazione ambiente)
# Database
DB_PASSWORD=your_secure_password_here

# Flask
SECRET_KEY=your-secret-key-here-generate-a-random-one
FLASK_ENV=production

# Email settings (per Gmail, usa App Password)
EMAIL_SENDER=your-email@gmail.com
EMAIL_PASSWORD=your-app-password

# Server
SERVER_URL=http://localhost:5000

# README.md per deployment
# 🏥 Health Monitor IoT - Deployment Guide

## Prerequisiti
- Docker e Docker Compose installati
- Python 3.10+
- Dataset FatigueSet scaricato

## Setup Rapido

### 1. Clone del repository
```bash
git clone https://github.com/your-username/iot-health-monitoring.git
cd iot-health-monitoring
```

### 2. Preparazione dataset
```bash
# Scarica il dataset da https://www.esense.io/datasets/fatigueset/
# Estrai i file CSV nella cartella data/fatigueset/
mkdir -p data/fatigueset
# Copia i file: wrist_acc.csv, wrist_bvp.csv, wrist_eda.csv, 
#              wrist_hr.csv, wrist_ibi.csv, wrist_skin_temperature.csv
```

### 3. Configurazione ambiente
```bash
# Copia il file .env di esempio
cp .env.example .env

# Modifica .env con i tuoi valori
nano .env
```

### 4. Avvio con Docker Compose
```bash
# Build e avvio di tutti i servizi
docker-compose up -d

# Verifica che tutto sia attivo
docker-compose ps

# Visualizza i log
docker-compose logs -f
```

### 5. Accesso al sistema
- Dashboard: http://localhost:5000
- Login admin: admin/admin123

## Deployment su Cloud

### AWS EC2
```bash
# 1. Crea istanza EC2 (Ubuntu 22.04)
# 2. Installa Docker
sudo apt update
sudo apt install docker.io docker-compose

# 3. Clone repository
git clone ...

# 4. Configura security groups:
#    - Port 5000 (Flask)
#    - Port 22 (SSH)

# 5. Avvia applicazione
docker-compose up -d
```

### Google Cloud Platform
```bash
# 1. Crea VM instance
gcloud compute instances create health-monitor \
  --image-family=ubuntu-2204-lts \
  --image-project=ubuntu-os-cloud

# 2. SSH nella VM
gcloud compute ssh health-monitor

# 3. Segui gli stessi step di AWS
```

### Heroku
```bash
# 1. Installa Heroku CLI
# 2. Login
heroku login

# 3. Crea app
heroku create health-monitor-iot

# 4. Aggiungi PostgreSQL
heroku addons:create heroku-postgresql:hobby-dev

# 5. Deploy
git push heroku main
```

## Monitoraggio e Manutenzione

### Backup Database
```bash
# Backup
docker exec health_monitor_db pg_dump -U health_user health_monitoring > backup.sql

# Restore
docker exec -i health_monitor_db psql -U health_user health_monitoring < backup.sql
```

### Monitoring
```bash
# CPU e memoria
docker stats

# Logs
docker-compose logs -f web

# Database status
docker exec health_monitor_db psql -U health_user -c "SELECT count(*) FROM sensor_data;"
```

## Troubleshooting

### Problema: Container non si avvia
```bash
# Controlla logs
docker-compose logs web

# Ricostruisci immagini
docker-compose build --no-cache
docker-compose up -d
```

### Problema: Errori di connessione database
```bash
# Verifica che postgres sia attivo
docker-compose ps postgres

# Test connessione
docker exec -it health_monitor_db psql -U health_user health_monitoring
```

## Sicurezza

1. **Cambia password di default**
   - Admin password nel primo login
   - Database password in .env

2. **HTTPS con Nginx**
```nginx
server {
    listen 443 ssl;
    server_name your-domain.com;
    
    ssl_certificate /path/to/cert.pem;
    ssl_certificate_key /path/to/key.pem;
    
    location / {
        proxy_pass http://localhost:5000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```

3. **Firewall**
```bash
# Solo porte necessarie
sudo ufw allow 22
sudo ufw allow 443
sudo ufw enable
```